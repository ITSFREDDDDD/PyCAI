#+AUTHOR: Character Unity Consortium
#+TITLE: PyCAI

#+TODO: REFACTOR REFACTOR-ADDTOCLASS REFACTOR-IMPLEMENTABLE REFACTOR-CASESWITCH REFACTOR-REGEX TODO | DONE DEPRECIATED

Pycai is a library for char.ai. It is intended to allow power users and those who do their web browsing through the terminal to have a tidy and accessible way to use char.ai.

Broadly speaking, the API uses web sockets to connect to car.ai like any ordinary user at its public endpoints. There is no tangible or meaningful difference between using the API and visiting char.ai with a web browser.

The API uses a collection of async methods 

#+begin_quote
If you like character.ai, don't be a dick. Please pay for char.ai+ and support the developers, also please support the creators of your favorite characters. 
#+end_quote

The PyCAI2 library is intended to fit a specific purpose. Interacting with character.ai's public web end-points in an accessible way. Encapsulation and modularity of programs means that it should be focused on this goal.

With that being said, we implement coincident features that add value to interacting with character.ai in a way that cannot be encapsulated in this library alone. These kinds of programs can be found in our organization's group repository. For example, see /card manager/, which implements card management and makes calls to any arbitrary character card endpoint through an adapter. Additionally, _the namespaces used in this code are consistent with the namespaces used in our additional projects (so you can expect the image class to be present and have similar methods such as generate and delete as it has here)_

#+note: tags like c-PyAsyncCAI2 represents the class the method belongs to. In this case PyAsyncCAI2

* Coding Requests
** Program to an interface (verbs), not abstract classes (nouns)
- Good: message.send
- Bad:  chat.new

* Logic
#+begin_example python
# This is a integration test
#       Managing a chat with a character
        message.next('CHAR', 'CHAT_ID', 'PARENT_ID')
        message.send('CHAR', 'CHAT_ID', 'TEXT', {AUTHOR})
        message.next('CHAR', 'MESSAGE')
        chat.create('CHAR', 'CHAT_ID', 'CREATOR_ID') #may have made a mistake here, it looks like there's a new chat function separate from new message, and I'm not sure if I handled that correctly
        character.get_histories('CHAR') #returns chat IDs?
        chat.get('CHAR')
        chat.get_history('CHAT_ID')
        message.rate(RATE, 'CHAT_ID', 'TURN_ID', 'CANDIDATE_ID')
        message.delete('CHAT_ID', 'TURN_ID')

#+end_example
** REFACTOR PySynCAI
PyAsyncCAI2 should just be renamed to PyCAI2. Actually, this should not even be necessary. There should be message class, so import should take the form "import message from PyCAI"
#+begin_src python
class PySynCAI:
  def __init__(
    self, token: str = None, plus: bool = False
  ):
  self.token = token
  self.plus = plus
  if plus: sub = 'plus'
  else: sub = 'beta'
  
  self.session = Session(
  headers={
    'User-Agent': 'okhttp/5.0.0-SNAPSHOT'
    }
   )
   setattr(self.session, 'url', f'https://{sub}.character.ai/')
   setattr(self.session, 'token', token)
   self.chat = self.chat(token, self.session)
   self.chat2 = self.chat2(token, None, self.session)
   async def ping(self):
     return self.session.get(
       'https://neo.character.ai/ping/'
     ).json()
     @asynccontextmanager
    async def connect(self, token: str = None):
      try:
        if token == None: key = self.token
        else: key = token
          setattr(self.session, 'token', key)
          try:
            self.ws = await websockets.connect(
              'wss://neo.character.ai/ws/',
              extra_headers = {
                'Cookie': f'HTTP_AUTHORIZATION="Token {key}"',
                }
             )
             except websockets.exceptions.InvalidStatusCode:
               raise AuthError('Invalid token')
               yield PyAsyncCAI2.chat2(key, self.ws, self.session)
        finally:
          await self.ws.close()
<<chat.PySyncAI>>

#+end_src
*** chat

#+note: these noweb blocks should just be tangled based on section headline level
#+BEGIN_SRC python :tangle "sample.py" :noweb yes
  class chat:

      <<get_history.chat>> # Gets a specific history from histories json object or from the chat object
      <<next.chat>> #default gets the next chat in sequence, if defined takes number parameter. Not yet defined
      <<create.chat>> #creates a new chat. might only be in v1
      <<get.chat>> # pulls the chat
#+END_SRC


**** get_history
#+name:get_history.chat
#+begin_src python
async def get_history(self, char: str, *, token: str = None):
  json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session, token=token, method='GET', neo=True)
  chat_id = json_out['chats'][0]['chat_id']
  r = await PyAsyncCAI2.request(f'turns/{chat_id}/', self.session, token=token, neo=True)
  turn_out = [{"turn_id": turn['turn_key']['turn_id'], "raw_content": turn['candidates'][0]['raw_content']} for turn in r['turns']]
  output = [f'["{turn["turn_id"]}", "{turn["raw_content"]}"]' for turn in turn_out]
  return output

#+end_src

*** REFACTOR message
#+begin_src python
  class message:
     <<init.message>> # these are indented
     <<send.message>> # these are indented
     <<delete.message>> # these are indented
     <<next.message>> #R# default gets the next message in sequence, if defined takes number parameter 
     <<rate.message>> # Assigns message value
#+end_src
*** REFACTOR imagen
imagen is called imagen ("imagine - image generate") to keep stuff as interfaces (verbs) and not abstract classes (nouns)
#+begin_src python
  class imagen:
    <<generate.imagen>>
#+end_src

***** REFACTOR Generate Image
#+begin_src python
        async def generate(
            self, char: str, chat_id: str, text: str,
            author_name:str, Return_img: bool = True, Return_all: bool = False, *, turn_id: str = None, candidate_id: str = None, token:str = None
        ):
            json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session,token=token,method='GET',neo=True)
            chat_id = json_out['chats'][0]['chat_id']
            creator_id = json_out['chats'][0]['creator_id']

            if turn_id != None and candidate_id != None:
                message['update_primary_candidate'] = {
                    'candidate_id': candidate_id,
                    'turn_key': {
                        'turn_id': turn_id,
                        'chat_id': chat_id
                    }
                }

            message = {
                'command': 'create_and_generate_turn',
                'payload': {
                    'character_id': char,
                    'turn': {
                        'turn_key': {'chat_id': chat_id},
                        "author": {
                                "author_id": creator_id,
                                "is_human": True,
                                "name   ": author_name},
                        'candidates': [{'raw_content': text}]
                    }
                }
            }

            await self.ws.send(json.dumps(message))

            while True:
                response = json.loads(await self.ws.recv())
                try: response['turn']
                except: raise ServerError(response['comment'])

                if not response['turn']['author']['author_id'].isdigit():
                    try: is_final = response['turn']['candidates'][0]['is_final']
                    except: pass
                    else:
                        if Return_all:
                            r_in = response['turn']['candidates'][0]['raw_content']
                            img_in = response['turn']['candidates'][0]['tti_image_rel_path']  # Perhatikan perubahan indeks ke 0 di sini
                            results = f"{r_in}\n{img_in}"
                            return results
                        if Return_img:
                            r = response['turn']['candidates'][0]['tti_image_rel_path']
                            return r

#+end_src


**** REFACTOR character
#+begin_src python
class character:
<<get_histories.character>> # gets json of all character histories
<<get_avatar.character>> # gets the character avatar image
<<get_information.character>> ## contains description, author, etc. needs to be defined, gets called in the example. Dictionary file
#+end_src


**** REFACTOR init
#+begin_src python
        def __init__(
            self, token: str,
            ws: websockets.WebSocketClientProtocol,
            session: Session
        ):
            self.token = token
            self.session = session
            self.ws = ws
#+end_src


**** REFACTOR Error handling

**** REFACTOR create_image
#+begin_src python

#+end_src
**** REFACTOR send_message
the name send_message should be renamed to "create"
#+begin_src python
        async def send_message(
            self, char: str,
            text: str, author_name:str,
            *, turn_id: str = None,token:str = None,
            candidate_id: str = None, Return_name: bool = False
        ):

            json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session,token=token,method='GET',neo=True)
            chat_id = json_out['chats'][0]['chat_id']
            creator_id = json_out['chats'][0]['creator_id']

            message = {
                'command': 'create_and_generate_turn',
                'payload': {
                    'character_id': char,
                    'turn': {
                        'turn_key': {'chat_id': chat_id},
                         "author": {
                                "author_id": creator_id,
                                "is_human": True,
                                "name   ": author_name},
                        'candidates': [{'raw_content': text}]
                    }
                }
            }

            if turn_id != None and candidate_id != None:
                message['update_primary_candidate'] = {
                    'candidate_id': candidate_id,
                    'turn_key': {
                        'turn_id': turn_id,
                        'chat_id': chat_id
                    }
                }

            await self.ws.send(json.dumps(message))

            while True:
                response = json.loads(await self.ws.recv())
                try: response['turn']
                except: raise ServerError(response['comment'])

                if not response['turn']['author']['author_id'].isdigit():
                    try: is_final = response['turn']['candidates'][0]['is_final']
                    except: pass
                    else:
                        if Return_name:
                            r_in = response['turn']['candidates'][0]['raw_content']
                            n_in = response['turn']['author']["name"]
                            r = f"({n_in}) {r_in}"
                            return r
                        else:
                            r = response['turn']['candidates'][0]['raw_content']
                            return r




                            

#+end_src
**** REFACTOR delete_message
the name delete_message should be renamed to "delete"
#+begin_src python

#+end_src
**** Translate
This function should be moved into a different repository such as chat_manager, since it isn't necessary for CAI.
#+begin_src python
        async def transl(text:str, target:str, source:str):
            translator = esgt(
            source_language=source,
            target_language=target)

            resoult = translator.translate(text)

            return result

#+end_src
**** next_message
***** REFACTOR-IMPLEMENTABLE next-message
#+begin_src python :c-pyasynccai2-chat:
        async def next_message(
            self, char: str, parent_msg_uuid: str,token:str = None
        ):
            setup = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session,token=token,method='GET',neo=True)
            chat_id = setup['chats'][0]['chat_id']
            await self.ws.send(json.dumps({
                'command': 'generate_turn_candidate',
                'payload': {
                    'character_id': char,
                    'turn_key': {
                        'turn_id': parent_msg_uuid,
                        'chat_id': chat_id
                    }
                }
            }))
            
            while True:
                response = json.loads(await self.ws.recv())
                try: response['turn']
                except: raise ServerError(response['comment'])

                if not response['turn']['author']['author_id'].isdigit():
                    try: is_final = response['turn']['candidates'][0]['is_final']
                    except: pass
                    else: return response
            #+end_src

**** get_histories
Gets chat histories 
#+begin_src python
            async def get_histories(
            self, char: str = None, *,
            preview: int = 2, token: str = None
        ):
            return await PyAsyncCAI2.request(
                f'chats/?character_ids={char}'
                f'&num_preview_turns={preview}',
                self.session, token=token, neo=True
            )

#+end_src


**** get_avatar
This should probably be placed in a character class, not a message class
#+begin_src python
        async def get_avatar(self, char:str,*, token:str = None):
            json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session, token=token, method='GET', neo=True)
            avatar_url = json_out["chats"][0]["character_avatar_uri"]
            full_link = f"https://characterai.io/i/80/static/avatars/{avatar_url}"
            return full_link
#+end_src
** Search
Finds a list of characters
** Setup
#+begin_src python
from contextlib import asynccontextmanager
import websockets
import json
import base64
import os
import shutil
from curl_cffi.requests import Session
from pydub import AudioSegment
from io import BytesIO
from easygoogletranslate import EasyGoogleTranslate as esgt

# ███████             ██████      ██     ██  ████
#░██░░░░██  ██   ██  ██░░░░██    ████   ░██ █░░░ █
#░██   ░██ ░░██ ██  ██    ░░    ██░░██  ░██░    ░█
#░███████   ░░███  ░██         ██  ░░██ ░██   ███
#░██░░░░     ░██   ░██        ██████████░██  █░░
#░██         ██    ░░██    ██░██░░░░░░██░██ █
#░██        ██      ░░██████ ░██     ░██░██░██████
#░░        ░░        ░░░░░░  ░░      ░░ ░░ ░░░░░░
# BUILD BY @Falco_TK    (https://github.com/FalcoTK)
# CODE  BY @kramcat     (https://github.com/kramcat)
# CODE  BY @background  (https://github.com/backaround)
# CODE  BY @ITSFRED9999 (https://github.com/fred)
# When making a pull request, please put your information here
# =============================================================
# Need support? Open a discord ticket at (discord: tokaifalco_)
# =============================================================

__all__ = ['PyCAI2', 'PyAsyncCAI2']

#+end_src
** REFACTOR Error handling
#+begin_src python
class PyCAI2EX(Exception):
    pass

class ServerError(PyCAI2EX):
    pass

class LabelError(PyCAI2EX):
    pass

class AuthError(PyCAI2EX):
    pass

class PostTypeError(PyCAI2EX):
    pass

#+end_src


* Abstract functions
Functions that aren't the core logic of the library but called in methods
** Print
Prints JSON, jq is current implementation
** REFACTOR-CASESWITCH REFACTOR-REGEX Request :c-PyAsyncCAI2:
#+begin_src python
    async def request(
        url: str, session: Session,
        *, token: str = None, method: str = 'GET',
        data: dict = None, split: bool = False,
        split2: bool = False, neo: bool = False
    ):

        if neo:
            link = f'https://neo.character.ai/{url}'
        else:
            link = f'{session.url}{url}'

        if token == None:
            key = session.token
        else:
            key = token

        headers = {
            'Authorization': f'Token {key}',
        }

        if method == 'GET':
            response = session.get(
                link, headers=headers
            )

        elif method == 'POST':
            response = session.post(
                link, headers=headers, json=data
            )

        elif method == 'PUT':
            response = session.put(
                link, headers=headers, json=data
            )
            
        if split:
            data = json.loads(response.text.split('\n')[-2])
        elif split2:
            lines = response.text.strip().split('\n')
            data = [json.loads(line) for line in lines if line.strip()] # List
        else:
            data = response.json()

        if str(data).startswith("{'command': 'neo_error'"):
            raise ServerError(data['comment'])
        elif str(data).startswith("{'detail': 'Auth"):
            raise AuthError('Invalid token')
        elif str(data).startswith("{'status': 'Error"):
            raise ServerError(data['status'])
        elif str(data).startswith("{'error'"):
            raise ServerError(data['error'])
        else:
            return data
#+end_src
** REFACTOR 

** Pulls an image
** Delete message


