#+TODO: REFACTOR REFACTOR-ADDTOCLASS REFACTOR-IMPLEMENTABLE REFACTOR-CASESWITCH REFACTOR-REGEX TODO | DONE DEPRECIATED

Pycai is a library for char.ai. It is intended to allow power users and those who do their web browsing through the terminal to have a tidy and accessible way to use char.ai.

Broadly speaking, the API uses web sockets to connect to car.ai like any ordinary user at its public endpoints. There is no tangible or meaningful difference between using the API and visiting char.ai with a web browser.

The API uses a collection of async methods 

#+begin_quote
If you like character.ai, don't be a dick. Please pay for char.ai+ and support the developers, also please support the creators of your favorite characters. 
#+end_quote

The PyCAI2 library is intended to fit a specific purpose. Interacting with character.ai's public web end-points in an accessible way. Encapsulation and modularity of programs means that it should be focused on this goal.

With that being said, we implement coincident features that add value to interacting with character.ai in a way that cannot be encapsulated in this library alone. These kinds of programs can be found in our organization's group repository. For example, see /card manager/, which implements card management and makes calls to any arbitrary character card endpoint through an adapter.

#+note: tags like c-PyAsyncCAI2 represents the class the method belongs to. In this case PyAsyncCAI2
* Core functions
** Search
Finds a list of characters
** REFACTOR PySyncAI
PyAsyncCAI2 should just be renamed to PyCAI2. Actually, this should not even be necessary. There should be message class, so import should take the form "import message from PyCAI"

*** chat

        Managing a chat2 with a character

        chat.next_message('CHAR', 'CHAT_ID', 'PARENT_ID')
        chat.send_message('CHAR', 'CHAT_ID', 'TEXT', {AUTHOR})
        chat.next_message('CHAR', 'MESSAGE')
        chat.new_chat('CHAR', 'CHAT_ID', 'CREATOR_ID')
        chat.get_histories('CHAR')
        chat.get_chat('CHAR')
        chat.get_history('CHAT_ID')
        chat.rate(RATE, 'CHAT_ID', 'TURN_ID', 'CANDIDATE_ID')
        chat.delete_message('CHAT_ID', 'TURN_ID')

        

Currently the following sources are within the chat class. However, I think they should be refactored to go into a message class to make the code more of an interface and less of an abstract class (programming to an interface).

The name chat should be refactored to "message".

**** REFACTOR send_message
the name send_message should be renamed to "create"
#+begin_src python
        async def send_message(
            self, char: str,
            text: str, author_name:str,
            *, turn_id: str = None,token:str = None,
            candidate_id: str = None, Return_name: bool = False
        ):

            json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session,token=token,method='GET',neo=True)
            chat_id = json_out['chats'][0]['chat_id']
            creator_id = json_out['chats'][0]['creator_id']

            message = {
                'command': 'create_and_generate_turn',
                'payload': {
                    'character_id': char,
                    'turn': {
                        'turn_key': {'chat_id': chat_id},
                         "author": {
                                "author_id": creator_id,
                                "is_human": True,
                                "name   ": author_name},
                        'candidates': [{'raw_content': text}]
                    }
                }
            }

            if turn_id != None and candidate_id != None:
                message['update_primary_candidate'] = {
                    'candidate_id': candidate_id,
                    'turn_key': {
                        'turn_id': turn_id,
                        'chat_id': chat_id
                    }
                }

            await self.ws.send(json.dumps(message))

            while True:
                response = json.loads(await self.ws.recv())
                try: response['turn']
                except: raise ServerError(response['comment'])

                if not response['turn']['author']['author_id'].isdigit():
                    try: is_final = response['turn']['candidates'][0]['is_final']
                    except: pass
                    else:
                        if Return_name:
                            r_in = response['turn']['candidates'][0]['raw_content']
                            n_in = response['turn']['author']["name"]
                            r = f"({n_in}) {r_in}"
                            return r
                        else:
                            r = response['turn']['candidates'][0]['raw_content']
                            return r




                            

#+end_src
**** REFACTOR delete_message
the name delete_message should be renamed to "delete"
#+begin_src python

#+end_src
**** Translate
This function should be moved into a different repository such as chat_manager, since it isn't necessary for CAI.
#+begin_src python
        async def transl(text:str, target:str, source:str):
            translator = esgt(
            source_language=source,
            target_language=target)

            resoult = translator.translate(text)

            return result

#+end_src
**** next_message
***** REFACTOR-IMPLEMENTABLE next-message
#+begin_src python :c-pyasynccai2-chat:
        async def next_message(
            self, char: str, parent_msg_uuid: str,token:str = None
        ):
            setup = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session,token=token,method='GET',neo=True)
            chat_id = setup['chats'][0]['chat_id']
            await self.ws.send(json.dumps({
                'command': 'generate_turn_candidate',
                'payload': {
                    'character_id': char,
                    'turn_key': {
                        'turn_id': parent_msg_uuid,
                        'chat_id': chat_id
                    }
                }
            }))

            while True:
                response = json.loads(await self.ws.recv())
                try: response['turn']
                except: raise ServerError(response['comment'])

                if not response['turn']['author']['author_id'].isdigit():
                    try: is_final = response['turn']['candidates'][0]['is_final']
                    except: pass
                    else: return response
            #+end_src

**** get_histories
Gets chat histories 
#+begin_src python
            async def get_histories(
            self, char: str = None, *,
            preview: int = 2, token: str = None
        ):
            return await PyAsyncCAI2.request(
                f'chats/?character_ids={char}'
                f'&num_preview_turns={preview}',
                self.session, token=token, neo=True
            )

#+end_src

**** get_history
#+begin_src python
        async def get_history(self, char: str, *, token: str = None):
            json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session, token=token, method='GET', neo=True)
            chat_id = json_out['chats'][0]['chat_id']
            r = await PyAsyncCAI2.request(f'turns/{chat_id}/', self.session, token=token, neo=True)
            turn_out = [{"turn_id": turn['turn_key']['turn_id'], "raw_content": turn['candidates'][0]['raw_content']} for turn in r['turns']]
            output = [f'["{turn["turn_id"]}", "{turn["raw_content"]}"]' for turn in turn_out]
            return output

#+end_src



* Abstract functions
Functions that aren't the core logic of the library but called in methods
** Print
Prints JSON, jq is current implementation
** REFACTOR-CASESWITCH REFACTOR-REGEX Request :c-PyAsyncCAI2:
#+begin_src python
    async def request(
        url: str, session: Session,
        *, token: str = None, method: str = 'GET',
        data: dict = None, split: bool = False,
        split2: bool = False, neo: bool = False
    ):

        if neo:
            link = f'https://neo.character.ai/{url}'
        else:
            link = f'{session.url}{url}'

        if token == None:
            key = session.token
        else:
            key = token

        headers = {
            'Authorization': f'Token {key}',
        }

        if method == 'GET':
            response = session.get(
                link, headers=headers
            )

        elif method == 'POST':
            response = session.post(
                link, headers=headers, json=data
            )

        elif method == 'PUT':
            response = session.put(
                link, headers=headers, json=data
            )
            
        if split:
            data = json.loads(response.text.split('\n')[-2])
        elif split2:
            lines = response.text.strip().split('\n')
            data = [json.loads(line) for line in lines if line.strip()] # List
        else:
            data = response.json()

        if str(data).startswith("{'command': 'neo_error'"):
            raise ServerError(data['comment'])
        elif str(data).startswith("{'detail': 'Auth"):
            raise AuthError('Invalid token')
        elif str(data).startswith("{'status': 'Error"):
            raise ServerError(data['status'])
        elif str(data).startswith("{'error'"):
            raise ServerError(data['error'])
        else:
            return data
#+end_src
** REFACTOR 

** Pulls an image
** Delete message


