#+TODO: REFACTOR REFACTOR-ADDTOCLASS REFACTOR-IMPLEMENTABLE REFACTOR-CASESWITCH REFACTOR-REGEX TODO | DONE DEPRECIATED

Pycai is a library for char.ai. It is intended to allow power users and those who do their web browsing through the terminal to have a tidy and accessible way to use char.ai.

Broadly speaking, the API uses web sockets to connect to car.ai like any ordinary user at its public endpoints. There is no tangible or meaningful difference between using the API and visiting char.ai with a web browser.

The API uses a collection of async methods 

#+begin_quote
If you like character.ai, don't be a dick. Please pay for char.ai+ and support the developers, also please support the creators of your favorite characters. 
#+end_quote

The PyCAI2 library is intended to fit a specific purpose. Interacting with character.ai's public web end-points in an accessible way. Encapsulation and modularity of programs means that it should be focused on this goal.

With that being said, we implement coincident features that add value to interacting with character.ai in a way that cannot be encapsulated in this library alone. These kinds of programs can be found in our organization's group repository. For example, see /card manager/, which implements card management and makes calls to any arbitrary character card endpoint through an adapter.

#+note: tags like c-PyAsyncCAI2 represents the class the method belongs to. In this case PyAsyncCAI2
* Core functions
** Search
Finds a list of characters
** REFACTOR PySyncAI
*** chat
Currently the following sources are within the chat class. However, I think they should be refactored to go into a message class to make the code more of an interface and less of an abstract class (programming to an interface).

**** Next Message
***** REFACTOR-IMPLEMENTABLE next-message
#+begin_src python :c-pyasynccai2-chat:
        async def next_message(
            self, history_id: str, parent_msg_uuid: str,
            tgt: str, *, token: str = None, **kwargs
        ):
            response = await PyAsyncCAI2.request(
                'chat/streaming/', self.session,
                token=token, method='POST', split=True,
                data={
                    'history_external_id': history_id,
                    'parent_msg_uuid': parent_msg_uuid,
                    'tgt': tgt,
                    **kwargs
                }
            )
            #+end_src

**** Get Histories
***** Get histories
Get the histories of the character
#+begin_src python :c-pyasynccai2-chat:

#+end_src
**** Delete Message
Delete the message in the current chat, uuids ... 
#+begin_src python

        async def delete_message(
            self, history_id: str, uuids_to_delete: list,
            *, token: str = None, **kwargs
        ):
            return await PyAsyncCAI2.request(
                'chat/history/msgs/delete/', self.session,
                token=token, method='POST',
                data={
                    'history_id': history_id,
                    'uuids_to_delete': uuids_to_delete,
                    **kwargs
                }
            )
#+end_src
**** New Chat
#+begin_src python
        async def new_chat(
            self, char: str, *, with_greeting: bool = True, token:str =None
        ):
            json_out = await PyAsyncCAI2.request(f'chats/recent/{char}', self.session,token=token,method='GET',neo=True)
            chat_id = json_out['chats'][0]['chat_id']
            creator_id = json_out['chats'][0]['creator_id']

            message = {
                'command': 'create_chat',
                'payload': {
                    'chat': {
                        'chat_id': chat_id,
                        'creator_id': creator_id,
                        'visibility': 'VISIBILITY_PRIVATE',
                        'character_id': char,
                        'type': 'TYPE_ONE_ON_ONE'
                    },
                    'with_greeting': with_greeting
                }
            }
            await self.ws.send(json.dumps(message))

            response = json.loads(await self.ws.recv())
            print(response)

            try: response['chat']
            except KeyError:
                raise ServerError(response['comment'])
            else:
                answer = json.loads(await self.ws.recv())
                return response, answer

#+end_src

** Get_histories
Gets chat history
#+begin_src python
        async def get_histories(
            self, char: str, *, number: int = 50,
            token: str = None
        ):
            return await PyAsyncCAI2.request(
                'chat/character/histories_v2/', self.session,
                token=token, method='POST',
                data={'external_id': char, 'number': number},
            )
#+end_src

** get_histories 
** Abstract functions
Functions that aren't the core logic of the library but called in methods
*** Print
Prints JSON, jq is current implementation
*** REFACTOR-CASESWITCH REFACTOR-REGEX Request :c-PyAsyncCAI2:
#+begin_src python
    async def request(
        url: str, session: Session,
        *, token: str = None, method: str = 'GET',
        data: dict = None, split: bool = False,
        split2: bool = False, neo: bool = False
    ):

        if neo:
            link = f'https://neo.character.ai/{url}'
        else:
            link = f'{session.url}{url}'

        if token == None:
            key = session.token
        else:
            key = token

        headers = {
            'Authorization': f'Token {key}',
        }

        if method == 'GET':
            response = session.get(
                link, headers=headers
            )

        elif method == 'POST':
            response = session.post(
                link, headers=headers, json=data
            )

        elif method == 'PUT':
            response = session.put(
                link, headers=headers, json=data
            )
            
        if split:
            data = json.loads(response.text.split('\n')[-2])
        elif split2:
            lines = response.text.strip().split('\n')
            data = [json.loads(line) for line in lines if line.strip()] # List
        else:
            data = response.json()

        if str(data).startswith("{'command': 'neo_error'"):
            raise ServerError(data['comment'])
        elif str(data).startswith("{'detail': 'Auth"):
            raise AuthError('Invalid token')
        elif str(data).startswith("{'status': 'Error"):
            raise ServerError(data['status'])
        elif str(data).startswith("{'error'"):
            raise ServerError(data['error'])
        else:
            return data
#+end_src
*** REFACTOR 

** Pulls an image
** Delete message

